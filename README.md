# devops

**Build Commands:**

- go build -o ./build/currency-conversion ./currency-conversion/.
- go build -o ./build/exchange-rates ./exchange-rates/.

**Docker Commands:**

1. Build Docker Image:  
   docker build -t devops .
2. Start a network:  
   docker network create currency-network
3. Start redis connected to this network:  
   docker run --rm --net currency-network --name my_redis -p 6379:6379 -d redis
4. Start exchange-rates container:  
   docker run -it --net currency-network --name exchange_rate -p 9001:9001 devops
5. Start the other service:  
   docker run -it --net currency-network --name currency_conversion -p 9000:9000 devops ./currency-conversion
6. Log into container  
   docker exec -it <container id> sh
7. docker logs -f <container id>
   logs in follow mod for the container

**Kubernetes Commands:**

1. kubectl version
2. kubectl create
3. kubectl create deployment NAME --image=image . Example kubectl create deployment nginx-depl --image=nginx  
   Deployment have the minimalistic blueprint for creating a pod.  
   Between deployments and pods there is a layer of replica set.  
   This is automatically managed by k8. RS manages the replicas of the pod.  
   The name of replica set would be of the form <image-name>-<rs id>. The corresponding pod would have the name <image-name>-<rs id><pod id>  
   So, deployment - > replica set -> pods -> containers. We work at the level of deployments
4. kubectl get deployments
5. kubectl get pods
6. kubectl edit deployment nginx-depl  
   Gives autogenerated configuration file of the deployment which you can edit. Editing would terminate older pod and create new ones
7. Kubectl logs <podname>  
   Get the logs of the pod
8. kubectl describe pod <podname>  
   Gets additional info about the pod .useful for debugging
9. kubectl exec -it <podname> --bin/bash  
   To log into the pod
10. kubectl delete deployment <podname>  
    deletes the deployment ,pods and replicaset
11. kubectl apply -f <filename>  
    Apply a deployment configuration

**Labels and Selectors:**
In yml files for k8, the metadata contains the labels where as the specs(specifications) contain the selectors. Labels are key value pairs.
So template for pod has a label and selector of deployment has selector . So deployment knows which pod bolongs to it via label and selector
Service has a selector and deployment has a label . Service knows which pods and deplopyment belong to it via labels on deployment + template.

**Ports in Deployment and Services:**
Deployment has containerPort which is the port at which pod is listening to
Service has two ports: port: XX (this is the port where other services would request this service) and targetPort: YY (this is the port where service sends request to the target port). So , targetPort: YY in service config and containerPort: YY in deployment file should match

To verify the labels and selector is working and requests are forwarded to required port.

- Kubectl appy -f <deployment.yml>
- Kubectl appy -f <service.yml>
- Kubectl describe service <service name>
  Here you can see the service configuration and see the endpoints it would contain ip:ports to which requests would be forwarded to
- kubectl get pods -o wide
  This would give you the pod names with ip addresses

**External Service:** When we want to expose a service to outside world then specify type as LoadBalancer and nodePort > 30k.

**Namespaces:** A virtual cluster in kubernetes cluster. There are 4 namespace:

1. Kube-public : publically accessible data like config map
2. kube node lease: Holds information about heartbeat
3. default namespace: to create resources at the beginning if you have not created any namespace
4. kube system: system process and master processes are deployed here

Command to create namespace: kubectl create namespace <namespace name >

**Usecase of namespace:**

- default name space would filled with all the components for a complicated application. So its better to have different name space like db name space
- two different teams could have same deployment names and hence one can override another deployment
- blue green deployment: When we want to have two versions of same app: production1-namespace and production2-namespace. Both deployments can use same resources(like db)
- limit access to namespaces for different teams
- limit resources per namespaces

Each name space should have its own configname and secret. However services can be accessed from other namespaces via <namespace.service_name>
Volume cannot be namespaced but are global . To check which resources are not namespaced : kubectl api-resources --namespaced=false

**Creating components in Namespace**
Via Command: kubectl apply -f <filename> --namespace=<namespace>
Add namespace metadata in config files like:
metadata:
name: XXX
namespace: YYY
When you type kubectl get all it takes default name space.To get objects of another name space use kubectl get all -n <namespace>
