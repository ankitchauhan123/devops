# devops

**Build Commands:**

- go build -o ./build/currency-conversion ./currency-conversion/.
- go build -o ./build/exchange-rates ./exchange-rates/.

**Docker Commands:**

1. Build Docker Image:  
   docker build -t devops .
2. Start a network:  
   docker network create currency-network
3. Start redis connected to this network:  
   docker run --rm --net currency-network --name my_redis -p 6379:6379 -d redis
4. Start exchange-rates container:  
   docker run -it --net currency-network --name exchange_rate -p 9001:9001 devops
5. Start the other service:  
   docker run -it --net currency-network --name currency_conversion -p 9000:9000 devops ./currency-conversion
6. Log into container  
   docker exec -it <container id> sh
7. docker logs -f <container id>
   logs in follow mod for the container

**Kubernetes Commands:**

1. kubectl version
2. kubectl create
3. kubectl create deployment NAME --image=image . Example kubectl create deployment nginx-depl --image=nginx  
   Deployment have the minimalistic blueprint for creating a pod.  
   Between deployments and pods there is a layer of replica set.  
   This is automatically managed by k8. RS manages the replicas of the pod.  
   The name of replica set would be of the form <image-name>-<rs id>. The corresponding pod would have the name <image-name>-<rs id><pod id>  
   So, deployment - > replica set -> pods -> containers. We work at the level of deployments
4. kubectl get deployments
5. kubectl get pods
6. kubectl edit deployment nginx-depl  
   Gives autogenerated configuration file of the deployment which you can edit. Editing would terminate older pod and create new ones
7. Kubectl logs <podname>  
   Get the logs of the pod
8. kubectl describe pod <podname>  
   Gets additional info about the pod .useful for debugging
9. kubectl exec -it <podname> --bin/bash  
   To log into the pod
10. kubectl delete deployment <podname>  
    deletes the deployment ,pods and replicaset
11. kubectl apply -f <filename>  
    Apply a deployment configuration

**Labels and Selectors:**
In yml files for k8, the metadata contains the labels where as the specs(specifications) contain the selectors. Labels are key value pairs.
So template for pod has a label and selector of deployment has selector . So deployment knows which pod bolongs to it via label and selector
Service has a selector and deployment has a label . Service knows which pods and deplopyment belong to it via labels on deployment + template.

**Ports in Deployment and Services:**
Deployment has containerPort which is the port at which pod is listening to
Service has two ports: port: XX (this is the port where other services would request this service) and targetPort: YY (this is the port where service sends request to the target port). So , targetPort: YY in service config and containerPort: YY in deployment file should match

To verify the labels and selector is working and requests are forwarded to required port.

- Kubectl appy -f <deployment.yml>
- Kubectl appy -f <service.yml>
- Kubectl describe service <service name>
  Here you can see the service configuration and see the endpoints it would contain ip:ports to which requests would be forwarded to
- kubectl get pods -o wide
  This would give you the pod names with ip addresses
