# devops

**Build Commands:**

- go build -o ./build/currency-conversion ./currency-conversion/.
- go build -o ./build/exchange-rates ./exchange-rates/.

**Docker Commands:**

1. Build Docker Image:  
   docker build -t devops .
2. Start a network:  
   docker network create currency-network
3. Start redis connected to this network:  
   docker run --rm --net currency-network --name my_redis -p 6379:6379 -d redis
4. Start exchange-rates container:  
   docker run -it --net currency-network --name exchange_rate -p 9001:9001 devops
5. Start the other service:  
   docker run -it --net currency-network --name currency_conversion -p 9000:9000 devops ./currency-conversion
6. Log into container  
   docker exec -it <container id> sh
7. docker logs -f <container id>
   logs in follow mod for the container

**Kubernetes Commands:**

1. kubectl version
2. kubectl create
3. kubectl create deployment NAME --image=image . Example kubectl create deployment nginx-depl --image=nginx  
   Deployment have the minimalistic blueprint for creating a pod.  
   Between deployments and pods there is a layer of replica set.  
   This is automatically managed by k8. RS manages the replicas of the pod.  
   The name of replica set would be of the form <image-name>-<rs id>. The corresponding pod would have the name <image-name>-<rs id><pod id>  
   So, deployment - > replica set -> pods -> containers. We work at the level of deployments
4. kubectl get deployments
5. kubectl get pods
6. kubectl edit deployment nginx-depl  
   Gives autogenerated configuration file of the deployment which you can edit. Editing would terminate older pod and create new ones
7. Kubectl logs <podname>  
   Get the logs of the pod
8. kubectl describe pod <podname>
   Gets additional info about the pod
9. kubectl exec -it <podname> --bin/bash
   To log into the pod
